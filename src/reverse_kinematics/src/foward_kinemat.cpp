#include "foward_kinemat.h"

float T_temp1[4][4] = { 0 };
float T_temp2[4][4] = { 0 };

float T01_x0_90[4][4] = {
	{ 1,0, 0,0 },
{ 0,0,-1,0 },
{ 0,1, 0,0 },
{ 0,0, 0,1 }
};//ÈÆx0Öá×ª¶¯90¶È

float T12_x1_90[4][4] = {
	{ 1,0,0 ,0 },
{ 0,0,-1,0 },
{ 0,1,0 ,0 },
{ 0,0,0 ,1 }
};

float T12_z2_90[4][4] = {
	{ 0,-1,0 ,0 },
{ 1,0 ,0 ,0 },
{ 0,0 ,1 ,0 },
{ 0,0 ,0 ,1 }
};


float T23_x2_90[4][4] = {
	{ 1,0 ,0,0 },
{ 0,0 ,1,0 },
{ 0,-1,0,0 },
{ 0,0 ,0,1 }
};

float T23_z3_90[4][4] = {
	{ 0,-1,0,0 },
{ 1,0 ,0,0 },
{ 0,0 ,1,0 },
{ 0,0 ,0,1 }
};

float T34_z3_L1_x3_90[4][4] = {
	{ 1,0,0,0 },
{ 0,0,-1,0 },
{ 0,1,0,-DSE },
{ 0,0,0,1 }
};

float T34_z4_180[4][4] = {
	{ -1,0 ,0,0 },
{ 0 ,-1,0,0 },
{ 0 ,0 ,1,0 },
{ 0 ,0 ,0,1 }
};


float T45_y4_L2_x4_90[4][4] = {
	{ 1,0,0 ,0 },
{ 0,0,-1,DEW },
{ 0,1,0 ,0 },
{ 0,0,0 ,1 }
};

float T45_z5_90[4][4] = {
	{ 0,-1,0,0 },
{ 1,0 ,0,0 },
{ 0,0 ,1,0 },
{ 0,0 ,0,1 }
};



float T56_x5_90[4][4] = {
	{ 1,0 ,0,0 },
{ 0,0 ,1,0 },
{ 0,-1,0,0 },
{ 0,0 ,0,1 }
};

float T56_z6_90[4][4] = {
	{ 0,-1,0,0 },
{ 1,0 ,0,0 },
{ 0,0 ,1,0 },
{ 0,0 ,0,1 }
};


float T67_x6_90[4][4] = {
	{ 1,0,0 ,0 },
{ 0,0,-1,0 },
{ 0,1,0 ,0 },
{ 0,0,0 ,1 }
};
float T67_z7_90[4][4] = {
	{ 1,0,0,0 },
{ 0,1,0,0 },
{ 0,0,1,0 },
{ 0,0,0,1 }
};


void matrix_multiply(float *a, float *b, float *c, int x, int y, int z)
{
	float *ap, *bp;
	int row, colunm, k;
	for (row = 0; row < x; row+=1)
	{
		for (colunm = 0; colunm < z; colunm+=1)
		{
			ap = a + row * y;
			bp = b + colunm;
			*c = 0;
			for (k = 0; k < y; k += 1)
			{
				*c += *ap * *bp;
				ap = ap + 1;
				bp = bp + z;

			}
			c++;
		}
	}

}


void matrix_inv_3_3(float(*m1)[3], float(*m2)[3])
{
	int row;
	int column;
	float hangliezhi = m1[0][0] * m1[1][1] * m1[2][2] + m1[0][1] * m1[1][2] * m1[2][0] + m1[0][2] * m1[1][0] * m1[2][1] - m1[0][2] * m1[1][1] * m1[2][0] - m1[0][1] * m1[1][0] * m1[2][2] - m1[0][0] * m1[1][2] * m1[2][1];
	float M[3][3];
	M[0][0] = m1[1][1] * m1[2][2] - m1[1][2] * m1[2][1];
	M[0][1] = m1[1][0] * m1[2][2] - m1[1][2] * m1[2][0];
	M[0][2] = m1[1][0] * m1[2][1] - m1[1][1] * m1[2][0];

	M[1][0] = m1[0][1] * m1[2][2] - m1[0][2] * m1[2][1];
	M[1][1] = m1[0][0] * m1[2][2] - m1[0][2] * m1[2][0];
	M[1][2] = m1[0][0] * m1[2][1] - m1[0][1] * m1[2][0];

	M[2][0] = m1[0][1] * m1[1][2] - m1[0][2] * m1[1][1];
	M[2][1] = m1[0][0] * m1[1][2] - m1[0][2] * m1[1][0];
	M[2][2] = m1[0][0] * m1[1][1] - m1[0][1] * m1[1][0];

	for (row = 1; row<4; row++)
	{
		for (column = 1; column<4; column++)
		{
			m2[column - 1][row - 1] = pow(-1, row + column)*M[row - 1][column - 1] / hangliezhi;
		}
	}

}
